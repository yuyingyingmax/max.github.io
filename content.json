[{"title":"【leetCode】283.移动零","date":"2019-10-09T01:54:36.000Z","path":"2019/10/09/leetcode-283/","text":"283.移动零给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 示例: 输入: [0,1,0,3,12] 输出: [1,3,12,0,0] 说明: 必须在原数组上操作，不能拷贝额外的数组。尽量减少操作次数。 题解分析题目要求把0移动到数组末尾，那么我们很自然就可以想到，可以将非0元素都移动到数组左端，剩下的就填0，那么怎么做呢？ 原始做法 - 使用辅助数组我们可以将原数组中非0的元素复制到新数组中，然后将新数组的元素赋值给旧数组。 123456789101112131415public void moveZeroes(int[] nums)&#123; if(nums == null || nums.length == 0) return; int[] newArray = new int[nums.length]; int index = 0; //step1 : 复制非0元素 for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != 0)&#123; newArray[index++] = nums[i]; &#125; &#125; //step2：更新原数组 for(int i = 0; i &lt; newArray.length; i++)&#123; nums[i] = newArray[i]; &#125;&#125; 复杂度分析： 时间复杂度：O(n)空间复杂度：O(n) 这种方法不符合题目的要求，因为使用了辅助数组。 改进1 - 将非0元素填充到前一个0的位置，最后用0填充后面的位置由上一种方法可以想到，我们可以遍历一遍数组的时候，用index记录0元素的位置，遇到非0元素就将它填充到前一个0的位置上，使得[0,index)区间内都是非0元素，[index,nums.length)区间用0填充。 1234567891011121314public void moveZeroes(int[] nums)&#123; if(nums == null || nums.length == 0) return; int index = 0;//0元素初始位置 //step1:复制非0元素到前一个0元素位置 for(int i = 0; i &lt; nums.length; i++)&#123; if(nums[i] != 0)&#123; nums[index++] = nums[i]; &#125; &#125; //step2：将index之后的元素全部填充为0 while(index &lt; nums.length)&#123; nums[index++] = 0; &#125;&#125; 复杂度分析： 时间复杂度：O(n)空间复杂度：O(1) 考虑到最终还需要填充0，是否可以减少操作次数呢？ 改进2-将0元素与非0元素交换可以将0元素与非0元素交换，那么，就不存在最后一步填充0了。 这里还需要考虑到的一个极端情况是，数组没有0元素时，不管是改进1还是改进2都会对当前非0元素与自身进行复制/交换，可以通过添加一个小判断，减少操作的次数。 12345678910111213141516171819public void moveZeroes(int[] nums)&#123; if(nums == null || nums.length == 0) return; int index = 0; for(int i = 0; i &lt; nums.length;i++)&#123; if(nums[i] != 0)&#123;//非0元素 if(i != index)&#123;//如果i不等于index，才交换 swap(nums,i,index++); &#125;else&#123;//否则index++ index++; &#125; &#125; &#125;&#125;private void swap(int[] nums,int i, int j)&#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp;&#125; 复杂度分析： 时间复杂度：O(n)空间复杂度：O(1)"},{"title":"【关系抽取】相关概念-1","date":"2019-10-08T13:09:20.000Z","path":"2019/10/08/related-work-for-relations-extraction-adai/","text":"概述阿呆的paper： 关系抽取有两种框架，一种是pipeline方法，另一种是联合抽取方法。 传统的pipeline方法把抽取任务看作两个独立的抽取任务。首先利用然语言处理工具对文本中的实体进行识别，然后对实体之间的关系进行分类。 为了解决人工标注问题，神经模型在关系分类中得到了广泛的应用，包括卷积神经网络（CNN）、循环神经网络（RNN）和长期短期记忆网络（LSTM）。 基于深度学习的关系抽取 https://blog.csdn.net/qq_35203425/article/details/81138978 现有主流的关系抽取技术分为有监督的学习方法、半监督的学习方法和无监督的学习方法三种： 1、有监督的学习方法将关系抽取任务当做分类问题，根据训练数据设计有效的特征，从而学习各种分类模型，然后使用训练好的分类器预测关系。该方法的问题在于需要大量的人工标注训练语料，而语料标注工作通常非常耗时耗力。 2、半监督的学习方法主要采用Bootstrapping进行关系抽取。对于要抽取的关系，该方法首先手工设定若干种子实例，然后迭代地从数据从抽取关系对应的关系模板和更多的实例。 3、无监督的学习方法假设拥有相同语义关系的实体对拥有相似的上下文信息。因此可以利用每个实体对对应上下文信息来代表该实体对的语义关系，并对所有实体对的语义关系进行聚类。 与其他两种方法相比，有监督的学习方法能够抽取更有效的特征，其准确率和召回率都更高。因此有监督的学习方法受到了越来越多学者的关注，本文也将重点介绍该类方法。 相关论文整理mintz[5]首先提出了利用远程监控进行关系抽取。"},{"title":"【知识图谱】基础-1","date":"2019-10-08T03:06:51.000Z","path":"2019/10/08/KG-basic/","text":"什么是知识图谱？学术角度：知识图谱本质上是语义网络（Semantic Network）的知识库。 实际应用角度：多关系图（Multi-relational Graph）。 什么是多关系图？包含多种类型的节点和多种类型的边。 在知识图谱里，我们通常用“实体（Entity）”来表达图里的节点、用“关系（Relation）”来表达图里的“边”。实体指的是现实世界中的事物比如人、地名、概念、药物、公司等，关系则用来表达不同实体之间的某种联系。 知识图谱的表示知识图谱应用的前提是已经构建好了知识图谱，也可以把它认为是一个知识库。 属性图：当一个知识图谱拥有属性时，我们可以用属性图（Property Graph）来表示。 RDF：由很多的三元组（Triples）来组成。RDF 在设计上的主要特点是易于发布和分享数据，但不支持实体或关系拥有属性，如果非要加上属性，则在设计上需要做一些修改。 目前来看，RDF 主要还是用于学术的场景，在工业界我们更多的还是采用图数据库（比如用来存储属性图）的方式。 知识抽取知识图谱的构建是后续应用的基础，而且构建的前提是需要把数据从不同的数据源中抽取出来。对于垂直领域的知识图谱来说，它们的数据源主要来自两种渠道：一种是业务本身的数据，这部分数据通常包含在公司内的数据库表并以结构化的方式存储；另一种是网络上公开、抓取的数据，这些数据通常是以网页的形式存在所以是非结构化的数据。 前者一般只需要简单预处理即可以作为后续 AI 系统的输入，但后者一般需要借助于自然语言处理等技术来提取出结构化信息。比如在上面的搜索例子里，Bill Gates 和 Malinda Gate 的关系就可以从非结构化数据中提炼出来，比如维基百科等数据源。 信息抽取的难点在于处理非结构化数据. 在构建类似的图谱过程当中，主要涉及以下几个方面的自然语言处理技术： a. 实体命名识别（Name Entity Recognition） b. 关系抽取（Relation Extraction） c. 实体统一（Entity Resolution） d. 指代消解（Coreference Resolution） 在下面的图中，我们给出了一个实例。左边是一段非结构化的英文文本，右边是从这些文本中抽取出来的实体和关系。下面针对每一项技术解决的问题做简单的描述，以至于这些是具体怎么实现的，不在这里一一展开. 首先是实体命名识别，就是从文本里提取出实体并对每个实体做分类(打标签)：比如从上述文本里，我们可以提取出实体 -“NYC”，并标记实体类型为 “Location”；我们也可以从中提取出“Virgil’s BBQ”，并标记实体类型为“Restarant”。这种过程称之为实体命名识别，这是一项相对比较成熟的技术，有一些现成的工具可以用来做这件事情。 其次，我们可以通过关系抽取技术，把实体间的关系从文本中提取出来，比如实体“hotel”和“Hilton property”之间的关系为“in”；“hotel”和“Time Square”的关系为“near”等等。 另外，在实体命名识别和关系抽取过程中，有两个比较棘手的问题：一个是实体统一，也就是说有些实体写法上不一样，但其实是指向同一个实体。比如“NYC”和“New York”表面上是不同的字符串，但其实指的都是纽约这个城市，需要合并。实体统一不仅可以减少实体的种类，也可以降低图谱的稀疏性（Sparsity）. 另一个问题是指代消解，也是文本中出现的“it”, “he”, “she”这些词到底指向哪个实体，比如在本文里两个被标记出来的“it”都指向“hotel”这个实体。 实体统一和指代消解问题相对于前两个问题更具有挑战性 知识图谱的存储知识图谱主要有两种存储方式：一种是基于 RDF 的存储；另一种是基于图数据库的存储。 RDF 一个重要的设计原则是数据的易发布以及共享，图数据库则把重点放在了高效的图查询和搜索上。其次，RDF 以三元组的方式来存储数据而且不包含属性信息，但图数据库一般以属性图为基本的表示形式，所以实体和关系可以包含属性，这就意味着更容易表达现实的业务场景。 它们之间的区别如下图所示。 这里列出了常用的图数据库系统以及他们最新使用情况的排名。 其中 Neo4j 系统目前仍是使用率最高的图数据库，它拥有活跃的社区，而且系统本身的查询效率高，但唯一的不足就是不支持准分布式。 相反，OrientDB 和 JanusGraph（原 Titan）支持分布式，但这些系统相对较新，社区不如 Neo4j 活跃，这也就意味着使用过程当中不可避免地会遇到一些刺手的问题。如果选择使用 RDF 的存储系统，Jena 或许一个比较不错的选择。"},{"title":"【移动Web】知识点-1","date":"2019-09-29T01:37:25.000Z","path":"2019/09/29/2019-9-29-mobile-web-note-1/","text":"移动Web知识点Viewport什么是css像素，物理像素？ 手机打开PC页面刚好被等比例缩放？移动设备视窗概念 layout viewport（布局视窗）：浏览器初始视窗大小和浏览器厂商有关 Visual viewport（物理视窗）：可视范围的大小 Ideal viewport（理想视窗）：没有固定尺寸，不同设备的ideal viewport不同，所有iphone的ideal viewport都是320px，只要把某个个元素的宽度设为ideal viewport的宽度，那么这个元素的宽度就是屏幕的宽度。意义在于，无论何种分辨率的屏幕，针对ideal viewport设计的网站，不需要手动缩放，也不需要横向滚动条，都可以完美呈现。 等比例缩放是一种浏览器的特性，将页面缩到visual viewport的可视区域内。这个特性实际上有不好的地方，因为图片、文字都会缩小，使用手机浏览是非常不方便的。 设备宽高和viewport有什么关系？iphone、ipad以及IE会横竖屏不分，通通以竖屏的宽度为ideal viewport的宽度。 如何使用 meta设置viewport？如何设置ideal viewport？&lt;meta name = &quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt;这个meta标签的作用是，让当前viewport宽度等于设备宽度(ideal viewport的宽度)，同时不允许用户手动缩放。 meta viewport首先是苹果在safari引入的，在苹果的规范中，meta viewport有6个属性（content中）： width：设置layout viewport的宽度，正整数，或着字符串“width-device” initial-scale：页面的初始缩放值，数字，可以是小数。 minimum-scale：允许用户的最小缩放值，数字，可以是小数。 maximum-scale：允许用户的最大缩放值，数字，可以是小数。 heigh：设置layout viewport 的高度，这个属性并不重要，很少使用。 user-scalable：是否允许用户进行缩放，值“no”或“yes”，0或1. 在Android中还支持target-densitydpi这个私有属性，表示目标设备的密度等级，作用是决定css中的1px代表多少物理像素 target-densitypdi：可以是数值，或者字符串:”high-dpi”,”medium-dpi”,”low-dpi”,”device-dpi”中的一个。 当配置`target-densitypid=device-dpi”时，css中的1px会等于物理像素的1px。 因为只有android支持且Android决定放弃这个属性了，所以我们不要使用。 initial-scale &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0&quot;&gt; 也可以把当前viewport变为ideal viewport。设置为1说明梅索放，但却达到了ideal viewport的效果。说明缩放是相对于ideal viewport来进行缩放的 如果width和initial-scale = 1同时出现，并且冲突怎么办？ 假如width=400px，那么浏览器会取他们中的较大值。 最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病：&lt;meta name = &quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0, maximum-scale=1.0, user-scalable=0&quot;/&gt; 流式布局主要是这个属性：display:flex写在移动端：display:-webkit-flex; 这是CSS3中的属性。 控制子元素横着排列还是竖着排列 flex-direction:row|row-reverse|column|column-reverse; 换行，wrap强制换行,nowrap强制不换行，wrap-reverse flex-wrap:nowrap|wrap|wrap-reverse; justify-content:flex-start|flex-end|center|space-between|space-around; align-items:flex-start|flex-end|center|baseline|stretch; align-self:auto|flex-start|flex-end|center|baseline|stretch;"},{"title":"【LeetCode】 142.环形链表2","date":"2019-09-28T12:36:12.000Z","path":"2019/09/28/leetcode-cycle-list-2/","text":"142.环形链表2给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 说明：不允许修改给定的链表。 示例 1：输入：head = [3,2,0,-4], pos = 1输出：tail connects to node index 1解释：链表中有一个环，其尾部连接到第二个节点。 题解分析141题是判断链表是否有环，142题是判断入环的第一个节点。 判断链表有环的方法是：快慢指针。 那么对于入环的第一个节点怎么去找？ 假设从链表头部走到环的入口需要F步 假设两个指针相遇的时候，慢指针走了 a 步，快指针走了 a + b + a 步 由快慢的定义，我们知道f = 2s，因为快指针每次都走2步，慢指针走1步，快指针走了慢指针的两倍路程。 那么可以推出：2 (F + a) = F + a + b + aF = b 说明，入环之前这一段路程和b相同，那就意味着，我们用一个指针从头走F步，另一个指针从第一次相遇处走F步，当他们再次相遇时，说明这个点就是入口。 步骤1.快慢指针找到第一次相遇的位置2.快指针fast重新从head开始,slow继续从第一次相遇处，fast 和 slow 每次都只走一步，相遇时的位置就是环开始的位置。返回slow或者fast即可。 编码123456789101112131415161718public ListNode detectCycle(ListNode head) &#123; if(head==null || head.next == null) return null; ListNode fast = head; ListNode slow = head; while(true)&#123; if(fast == null || fast.next == null) return null; fast = fast.next.next; slow = slow.next; if(fast == slow) break; &#125; fast = head; while(fast != slow)&#123; fast = fast.next; slow = slow.next; &#125; return fast; &#125;"},{"title":"【MySQL】MySQL总结","date":"2019-09-28T10:52:22.000Z","path":"2019/09/28/Mysql-Summary/","text":"事务1.什么是事务？ 满足ACID特性的一组操作。 2.自动提交 MySQL中的事务都是自动提交的，如果不显式地使用START TRANSACTION来开启事务，那么每一个查询都会被当作一个事务。 3.事务的特性(ACID) 原子性：Atomicity，事务是一个不可再分的工作单位，事务中的操作要么都执行，要么都不执行。 一致性：Consistency，事务总是从一个一致状态转移到另一个一致状态。并发执行的事务，其结果和串行执行的结果一致（正确），那么就说这个并发事务符合一致性。 隔离性：Isolation，事务所做的修改在提交之前，对其他事务是不可见的。 持久性：Durability，事务所做的修改一旦提交，就会永久的保存在数据库中。 4.并发事务存在的问题 1.丢失更新：两个事务读取同一事务后，先后进行修改（或回滚）导致第一个提交的事务数据丢失。 2.脏读：事务读取到其他事务未提交的数据 3.不可重复读：事务A读取数据x但还没提交，事务B修改了X或删除了X并提交，事务A再次读取数据时，两次得到的结果不一致。针对update 和 delete。 4.幻读：事务A读取x = 100的数据得到了10条结果，事务B增加了一条x = 100的数据并提交，事务A再次读取时会得到11条结果，导致前后不一致。针对insert。 5.事务的隔离级别 1.未提交读 Read-Uncommited：事务中的修改即使没有提交也会被其他事务可见。(导致上述1、2、3问题) 2.提交读 Read-Commited ： 事务只会看到已提交事务做出的修改。（导致2，3） 3.可重复读 Repeatable-Read : 一个事务多次读取相同内容得到结果一致，也就是说，一个事务不会读取另一个事务修改但未提交的数据。（能解决2，不能解决3）。是MySQL默认的隔离级别。 MySQL通过MVCC（快照读） + next-key locking (当前读）解决了幻读的问题。 4.可串行化 Serializable : 强制事务串行执行。最高级别。 6.为什么MySQL默认隔离级别是RR？ MySQL在5.0之前binlog只有statement一种格式，这个格式在RC下，会出现主从不一致的情况，因此默认隔离级别是RR. 1.什么是binlog binlog记录所有数据库表结构变更（例如CREATE、ALTER TABLE…）以及表数据修改（INSERT、UPDATE、DELETE…）的二进制日志。binlog不会记录SELECT和SHOW这类操作，因为这类操作对数据本身并没有修改，但你可以通过查询通用日志来查看MySQL执行过的所有语句。 2.binlog的几种格式 statement：记录的是修改SQL语句row：记录每行实际数据变更mixed：上面两种的混合。 当binlog为statement格式，数据库隔离级别在RC情况下，在master节点先delete后insert，binlog里记录的是先insert后delete(按提交顺序,session2先提交)，slave同步的是binlog，因此从机执行的顺序和主机不一致！就会出现主从不一致。 3.如何解决？ 1)设置为RR,加入间隙锁，session2插入时会阻塞。 2)使用binlog的row格式，这个格式5.1才有。 因此MySQL的默认隔离级别是RR。 7.那既然说InnoDB通过MVCC解决了幻读，什么是MVCC？ 多版本并发控制。 通过为每一行数据保存两个隐藏的字段（创建时间，删除时间），使得大部分读操作都不需要加锁。 实际上保存的是版本号，每个事物开始都有一个版本号，递增。 SELECT InnoDB会根据以下两个条件检查每一行 行的创建版本号早于当前版本号，这样保证事物读取的数据是在事务开始之前就存在的，或者事务自己创建的。行的删除版本号大于当前版本号，或者未定义，这样保证事物发生时该行还没有被删除（修改）。 INSERT 为创建的行添加当前事务的版本号到行的创建版本号。 DELETE 为被删除的行添加当前事务的版本号到删除版本号。 UPDATE 为旧的数据添加当前版本号到删除版本号。 创建一行新纪录，保存当前版本号到创建版本号。 8.next-key locking 算法 next-key locking是一个行锁的算法，除他以外InnoDB还有两个行锁的算法，他们分别是： 1.Record Lock：锁直接加在索引记录上，锁住的是key 2.Gap Lock:间隙锁，锁定索引记录的间隙（不包括记录本身），保证间隙不变，它是针对隔离级别为RR及以上的事务来说的。 3.Next-key locking：上面这两个家伙组合起来就是next-key locking。锁定间隙且锁定记录本身。 之前说，InnoDB通过MVCC解决了幻读的问题，但他是在快照读的层面实现的（简单的select），next-key locking是在当前读层面来实现的，而且默认情况下是针对RR级别的。 在使用next-key locking的时候，当InnoDB扫描索引记录时，会先对索引加上行锁（record lock）然后在索引两边的间隙加上间隙锁（gap lock），这样就不能在间隙的位置进行修改或插入，从而防止幻读的发生。 9.锁的降级 当索引含有唯一属性时，Next-key Locking 会自动降级为Record Lock 用来减少锁定的范围，加大并发的处理速度。但是此种情况只存在于查询【所有的唯一索引列】。如果，唯一索引由多个列组成，而查询是查找多个唯一索引列中的其中一个，那么这种查询由于联合索引的特性，查询是一个范围查询，而不是点查询，所以不会降级处理。 索引1.设计索引的原则 1.最适合的索引列出现在where子句中，或者连接子句指定的列。 2.使用唯一索引。 3.使用短索引。对于varchar类型的字段，使用前缀索引效率会高。可以指定一个前缀长度，在这个长度内是唯一的。 4.利用最左前缀。 5.不要过度索引，不要建立太多的索引。 6.考虑列上进行比较的类型，索引可以用于&lt;、&lt;=、=、&gt;=、&gt;和between运算，模式具有一个直接前缀的时候可以用于like运算。 7.索引列的顺序非常重要！选择性最高的列放在最前面，选择性：不重复的索引值/总的记录数 8.索引列不能是表达式的一部分，也不能是函数的参数。 9.覆盖索引，可以充分利用二级索引中的主键值来覆盖查询 10.索引和锁： 索引可以让查询锁定更少的行 即使使用索引也有可能锁住不需要的数据，例如索引为 查询为where id &lt; 5 and id&lt;&gt;1 for update，虽然不需要id=1的数据，但mysql执行计划是索引范围扫描，因此&lt;5的都锁住了。 InnoDB在二级索引上使用共享锁，访问主键需要排他锁，并且使用select for update比lock in share mode或非锁定查询要慢 2.什么情况不会用到索引？ 1.当MySQL估计全表比索引快时，不用索引。 2.当跳过索引中的列。 当索引为&lt;a,b,c&gt; 查询where a = 10 and c= 100，就只会用到索引的第一列。 3.违反最左前缀。当索引为&lt;a,b,c&gt;时，where b = 100 或 where b = 100 and c = 100 或where c = 100都不会用到索引。 4.查询中有某个列的范围查询，则这个列的右边都无法用到索引。当索引为&lt;a,b,c&gt;时，查询where a = 10 and b like “bbv%” and c = 98，这个查询只用到索引的前两列&lt;a,b&gt;。 5.前导的模糊查询不会用到索引，where a like “%as”不会，但where a like “as%”可以用。 6.使用聚合函数索引会失效。 7.列类型是字符串，查询条件未加引号。 8.在查询条件中使用OR会失效，可以为每个or的字段都加索引（不太好吧） 3.InnoDB的聚簇索引是什么？优点和缺点是什么？ 更多：https://www.jianshu.com/p/fa8192853184 聚簇索引是InnoDB存储数据的方式，在同一个结构中保存了索引和数据行，数据存放在索引叶子页中。 InnoDB通过主键聚集数据。 优点： 1.可以把相关的数据保存在一起。 由于行数据和叶子节点存储在一起，同一页中会有多条行数据，访问同一数据页不同行记录时，已经把页加载到了Buffer中，再次访问的时候，会在内存中完成访问，不必访问磁盘。这样主键和行数据是一起被载入内存的，找到叶子节点就可以立刻将行数据返回了，如果按照主键Id来组织数据，获得数据更快。 2.数据访问更快，因为索引和数据是存放在一起的。（只需要一次查询） 3.使用覆盖索引扫描可以直接使用主键值。 缺点： 1.插入速度严重依赖于查询顺序，使用自增的主键是最快的插入方式。 2.更新代价很高，会强制被更新的行移动到新的位置。 3.导致页分裂。当主键值要求必须在已满（16K）的页中插入一条数据，会导致页分裂，页分裂会占用更多的空间。 4.二级索引可能会比想象的更大，因为二级索引中包含了主键，如果主键很大，那么其他索引都会很大。 5.二级索引的查找需要两次索引查找。自适应哈希索引能减少这样的重复工作。 自适应哈希索引：当InnoDB注意到某些索引值被频繁使用时，他会在内存中基于B+Tree索引之上再创建一个哈希索引。这是一个自动的内部行为，用户无法控制或配置，如果有必要也可以关闭这个功能。 4.二级索引的好处？ 二级索引存储了主键的值，虽然会消耗更多的空间，但是这样会减少出现页分裂时二级索引的维护，InnoDB在移动行时无需更新二级索引的id。 5.覆盖索引 优秀的索引应该考虑到整个查询而不单单只是where部分。如果一个索引能覆盖所有需要查询的字段（包括select部分的）那么就称之为覆盖索引。覆盖索引能极大提高性能，索引的条目通常远小于数据的数量，如果只需要读取索引那就能极大减少访问量。 由于聚簇索引，覆盖索引对InnoDB的表特别有用。InnoDB的二级索引在叶子结点保存了主键的值，如果二级索引能覆盖查询则可以避免对主键索引的二次访问。 explain的Extra列可以看到Using index，说明这个查询是索引覆盖查询。 6.哈希索引 InnoDB 引擎有一个特殊的功能叫 “自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制： 1.无法用于排序与分组； 2.只支持精确查找，无法用于部分查找和范围查找 7.索引的优点 创建唯一性索引，保证数据库表中每一行数据的唯一性 大大加快数据的检索速度，这是创建索引的最主要的原因 加速数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义 在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间 通过使用索引，可以在查询中使用优化隐藏器，提高系统的性能 8.索引的缺点 -创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加-索引需要占用物理空间，除了数据表占用数据空间之外，每一个索引还要占一定的物理空间，如果建立聚簇索引，那么需要的空间就会更大-当对表中的数据进行增加、删除和修改的时候，索引也需要维护，降低数据维护的速度 9.为什么MySQL的索引要使用B+树而不是其它树形结构?比如B树？ 因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在非叶子节点中能保存的指针数量变少。 指针少的情况下要保存大量数据，只能增加树的高度，导致IO操作变多，查询性能变低； 锁1.快照读和当前读 快照读：简单的select操作属于快照读，不加锁（不包括select … for update,select … lock in share mode) 例如：select * from table where… 当前读：特殊的select，insert/update/delete操作，属于当前读，要加锁。 例如： select … for update select…lock in share mode insert… update… delete… 在这些操作中，都需要加锁，select … lock in share mode加的是共享锁（S），其他都是排他锁（X） 2.共享锁和排他锁 共享锁：又叫做读锁，读锁是共享的，用户可以并发读，但不能修改，也就是说，事务A对数据加上共享锁后，别的事务也可以对数据加共享锁，但不能加排他锁。 select…lock in share mode 在select语句后面加上lock in share mode，MySQL对结果的每行都加共享锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请共享锁，否则会被阻塞。其他线程也可以读取使用了共享锁的表，而且这些线程读取的是同一个版本的数据。 排他锁：又叫写锁，写锁会阻塞其他的读锁和写锁，也就是当数据被加上排他锁后，再也无法对这个数据加任何锁，直到释放。 select … for update 在select语句后面加上for update时，MySQL会对查询结果中的每行都加排他锁，当没有其他线程对查询结果集中的任何一行使用排他锁时，可以成功申请排他锁，否则会被阻塞。 3.意向锁 意向锁：意向锁是表级锁，其设计目的主要是为了在一个事务中揭示下一行将要被请求锁的类型。 解释之前先说一下，意向锁是InnoDB自动加的，不需要用户干预，而共享锁和排他锁可以用户自己加（for update和lock in share mode） 假设事务A对数据表的某一行加了读锁，那么其他事务就只能读，不能写，也就是不能加排他锁。 此时有一个事务B对表申请一个表锁，如果他申请成功，那么也就意味着事务B对整个表拥有了写的权利，那事务A锁定的那一行不是矛盾了吗？ 数据库要避免冲突，那么就需要检查这个表是否被其他事务加了表锁，要是没加，就还得检查这个表的每一行是不是被锁住，这样就需要遍历整个表，效率不高，所以就有了意向锁。 有了意向锁，事务A在给表的某一行加锁前，需要先申请一个意向共享锁，成功后，再对这一行加行锁。 那么事务B再加锁前就需要先判断表上是否加了意向共享锁，如果有，就说明有些行被加了共享锁，这时事务B就阻塞了。 所以这么看来，意向锁的意思就可以这么表达：告诉事务这个表上有其他事务加了共享锁或排他锁。 加了意向共享锁（IS）的表，还可以被其他事务加IS，但被共享锁锁定的那些记录是不能被修改的。 加了意向排他锁（IX）的表，就不能被加任何共享锁和排他锁了。 意向锁是个表级的锁，共享锁和排他锁可以是行级也可以是表级，IX和IS只会和表级的X和S冲突，不会和行级的冲突。 意向锁实现了表锁和行锁的共存（举的那个例子就说明行锁和表锁共存时会有冲突） 并存的概念是指数据库同时支持表、行锁，而不是任何情况都支持一个表中同时有一个事务A持有行锁、又有一个事务B持有表锁，因为表一旦被上了一个表级的写锁，肯定不能再上一个行级的锁。 4.表锁和行锁 刚说S和X锁的时候我们提到了表锁和行锁，现在来解释一下： 表锁（table lock）：是MySQL中最基本的锁策略，且开销最小，他会锁定整张表 行锁（row lock）：给某一行加锁，行锁可以最大程度支持并发处理（同时带来最大的锁开销），行锁只在存储引擎层实现，而MySQL服务器层没有实现。 表锁和行锁是从锁的粒度来分的，X和S是从类型来分的，所以我们之前说，可以有行级的S和X锁，也可以有表级的S和X锁。 存储引擎1.InnoDB InnoDB是MySQL默认事务型引擎。 InnoDB采用MVCC来支持高并发，并且实现了四个标准的隔离级别。默认级别是RR，并通过间隙锁（next-key locking）策略防止幻读的出现。 InnoDB是基于聚簇索引建立的。 调优1.慢查询 查询性能低下的最基本原因是访问的数据太多。 分析步骤： 1.确认应用程序是否在检索大量不需要的数据。 2.确认MySQL服务器层时候在分析大量超过需要的行。 典型&lt;检索不需要数据&gt;情况： 1.SELECT * 每次看到这个的时候都需要想想，是不是真的需要表里全部的数据。 我们那个查找下载论文学生的查询，就SELECT * FROM STUDENT。 2.重复查询相同的数据 有的查询总是返回相同的结果，可以考虑用缓存。 2.向MySQL发送一个请求，MySQL到底做了什么？ 1.客户端发送一条查询给服务器 2.服务器先检查查询缓存，如果命中缓存，则立刻返回缓存中的结果。否则进入下一阶段。 解析SQL语句之前，如果查询缓存开启，则会优先检查这个缓存，是通过对大小写敏感的哈希查找实现的。如果命中，则在返回结果前会再检查一下用户权限，如果权限没有问题，则会跳过后面的阶段直接返回结果。 3.服务器进行SQL解析、预处理，再由查询优化器生成对应的执行计划。 SQL解析：通过关键字进行SQL语句解析，生成一颗“解析树”。预处理器：根据MySQL规则进一步检查解析树是否合法。（表和列是否存在，名字和别名是否有歧义）查询优化器：一条查询可以有很多种执行方式，优化器就是找到最好的执行计划。 4.MySQL根据优化器生成的执行计划，调用存储引擎的API来执行查询。 5.返回结果导到客户端。 3.EXPLAIN 分析查询 EXPLAIN可以对SELECT查询进行分析，所有字段如下： id：SELECT查询的标识符，每个SELECT都会分配一个唯一的标识符 select_type：SELECT查询的类型 table：查询的是哪个表 partitions：匹配的分区 type：mysql找到需要的数据行的方式 possible_keys：可能用到的索引 key：用到的索引 key_len：用到的索引的长度。 ref：哪个字段或常数和key一起使用。 rows：查询一共扫描了多少行，估计值。 filtered：此查询条件所过滤数据的百分比。 Extra：额外的信息。 -select_type - 查询类型 常用的取值有： SIMPLE, 表示此查询不包含 UNION 查询或子查询 （最常见） PRIMARY, 表示此查询是最外层的查询 UNION, 表示此查询是 UNION 的第二或随后的查询 DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询 UNION RESULT, UNION 的结果 SUBQUERY, 子查询中的第一个 SELECT DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果. type - MySQL找到需要数据行的方式 常取的值： const：针对主键或唯一索引的等值查询扫描, 最多只返回一行数据,const 查询速度非常快, 因为它仅仅读取一次即可。 eq_ref：此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 = , 查询效率较高。 ref：此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. range：表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中。 index：表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据。index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index。 ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免. ALL &lt; index &lt; range ~ &gt;index_merge &lt; ref &lt; eq_ref &lt; const &lt; system possible_keys - 可能用到的索引 表示能用的索引，并不代表真的用了，key表示用到的索引。 key - 使用的索引 查询使用的索引 key_len 使用索引的长度 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.key_len 的计算规则如下: 字符串 char(n): n 字节长度 varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节. 数值类型: TINYINT: 1字节 SMALLINT: 2字节 MEDIUMINT: 3字节 INT: 4字节 BIGINT: 8字节 时间类型 DATE: 3字节 TIMESTAMP: 4字节 DATETIME: 8字节 字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性. rows - 查询需要扫描的行数 MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好. Extra - 额外信息 Using index“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错 Using temporary查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化. 连接1.连接的种类1.外连接左连接 left join (left outer join)结果包括左表的所有行，如果右表有无法匹配的行则显示null。右连接 right join (right outer join)包括右表所有的行，如果左表又无法匹配的行，则显示null。 全连接 full join (full outer join)左表和右表其中一个表中存在匹配，则返回行。 2.内连接：内联接是用比较运算符比较要连接列的值的联接join 或 inner join 其他1.数据库中的范式 1NF：属性不可分 2NF：属性完全依赖于主键 [消除部分子函数依赖] 3NF：属性不依赖于其它非主属性 [消除传递依赖] 2.char 和 varchar的区别 char是定长的，varchar是变长的。 varchar在修改的时候可能会比原来长，原页面无法容纳时可能会导致分页。 varchar会保留字符串末尾的空格，char不保留。 3.分页查询怎么写？ select * from employee limit 3, 7; // 返回4-11行 select * from employee limit 3,1; // 返回第4行 SELECT * FROM message ORDER BY id DESC LIMIT 10000, 20 每次都要扫描10020行，然后只要20条记录，性能是不好的。 怎么写效率更好呢？ 如果只需要上一页和下一页，可以这么写： select * from message where id &gt; 10020 order by id desc limit 20;//下一页select * from message where id &lt; 10000 order by id desc limit 20;//上一页 这样就只需要扫描20行。 上一页 1 2 3 4 5 6 7 8 9 下一页 怎么实现呢？ 还是按照SELECT * FROM message ORDER BY id DESC，按id降序分页，每页20条 假设当前是第10页，当前页条目id最大的是2519，最小的是2500; 当前第10页的sql可以这么写: SELECT * FROM tb_goods_info WHERE auto_id &gt;=2500 ORDER BY auto_id ASC LIMIT 0,20 第9页： SELECT * FROM tb_goods_info WHERE auto_id &lt;2500 ORDER BY auto_id desc LIMIT 0,20 第8页： SELECT * FROM tb_goods_info WHERE auto_id &lt;2500 ORDER BY auto_id desc LIMIT 20,20 第11页： SELECT * FROM tb_goods_info WHERE auto_id &gt;2519 ORDER BY auto_id asc LIMIT 0,20 原理还是一样，记录住当前页id的最大值和最小值，计算跳转页面和当前页相对偏移，由于页面相近，这个偏移量不会很大，这样的话m值相对较小，大大减少扫描的行数。其实传统的limit m,n，相对的偏移一直是第一页，这样的话越翻到后面，效率越差，而上面给出的方法就没有这样的问题。 注意SQL语句里面的ASC和DESC，如果是ASC取出来的结果，显示的时候记得倒置一下。 4.数据库字段类型为什么建议尽量避免NULL 高性能MySQL中明确提到“尽量避免NULL” 原因： NOT IN、!= 等负向条件查询在有 NULL 值的情况下返回非空行的结果&gt;集。Count(*)会统计包括NULL的行，count(colName)不会统计此列为null的行NULL 列需要更多的存储空间，需要一个额外的字节作为判断是否为 NULL 的标志位。"},{"title":"【日记】不知道纪念什么的纪念日记","date":"2019-09-28T08:12:59.000Z","path":"2019/09/28/four/","text":"1当事情发生的时候，没有人会问你：“嗨，准备好了吗？” 而是就那样，发生了。 对工作是这样，对学业是这样，对感情也是这样。 2时常反省自己，做一个温柔的人，做一个认真的人，做一个努力生活的人。 虽然生活最近对我不太好，但我还是愿意热烈的爱着它。 我喜欢一个人走路，喜欢一个人吃饭。 我想谈一场简简单单的恋爱。 这些都很难吗？ 不知道。 尽人事，听天命吧。 3他日重逢，要等来生。 4《我用什么才能留住你》博尔赫斯 我用什么才能留住你？我给你瘦落的街道、绝望的落日、荒郊的月亮。我给你一个久久地望着孤月的人的悲哀。 我给你我已死去的祖辈，后人们用大理石祭奠的先魂：我父亲的父亲，阵亡于布宜诺斯艾利斯的边境，两颗子弹射穿了他的胸膛，死的时候蓄着胡子，尸体被士兵们用牛皮裹起； 我母亲的祖父——那年才二十四岁——在秘鲁率领三百人冲锋，如今都成了消失的马背上的亡魂。 我给你我的书中所能蕴含的一切悟力，以及我生活中所能有的男子气概和幽默。我给你一个从未有过信仰的人的忠诚。 我给你我设法保全的我自己的核心——不营字造句，不和梦交易，不被时间、欢乐和逆境触动的核心。 我给你早在你出生前多年的一个傍晚看到的一朵黄玫瑰的记忆。我给你关于你生命的诠释，关于你自己的理论，你的真实而惊人的存在。 我给你我的寂寞、我的黑暗、我心的饥渴；我试图用困惑、危险、失败来打动你。 5《如果我不曾见过太阳》狄金森 我本可忍受黑暗 如果我不曾见过太阳 然而阳光却把我的荒凉 照耀的更加荒凉 当你拥有过幸福，那么任何一点点的苦难都会变得分外强烈。"},{"title":"Hello World","date":"2019-09-28T02:09:06.924Z","path":"2019/09/28/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment"}]